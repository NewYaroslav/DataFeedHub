# Руководство по стилю DataFeedHub

## Основные принципы
1. **Единая терминология**: именование сущностей следует доменным шаблонам (ticks, bars, storage и т.д.), чтобы код легко соотносился с архитектурой. Если появляется новое направление, сперва найдите существующие примеры в `include/DataFeedHub/<domain>/` и повторите шаблон.
2. **Читаемость и предсказуемость**: используем однозначные соглашения для имён, форматирования и документации, чтобы разные домены проекта выглядели одинаково. Соседние файлы всегда служат примером, на который можно ориентироваться.
3. **Безопасность и переносимость**: избегаем приёмов, которые ломаются на разных платформах (например, `thread_local` STL-хранилищ), и опираемся на специальные вспомогательные типы. Любой «нестандартный» трюк должен быть обоснован и снабжён ссылкой на пример использования.
4. **Документация первого класса**: каждое публичное API сопровождаем полным Doxygen-блоком с упорядоченными тегами, как показано на примерах в `include/DataFeedHub/storage/common/interfaces/IConnection.hpp`.

## Оглавление
1. [Организация исходников и файлов](#организация-исходников-и-файлов)
2. [Правила именования](#правила-именования)
3. [Форматирование](#форматирование)
4. [Документирование и комментарии](#документирование-и-комментарии)
5. [Feature toggles и условная компиляция](#feature-toggles-и-условная-компиляция)
6. [Domain-driven дизайн](#domain-driven-дизайн)
7. [Практические рекомендации](#практические-рекомендации)

## Организация исходников и файлов
- Заголовки преимущественно загружаются из `include/DataFeedHub/...`. Следуйте уже существующей иерархии: `compression/`, `data/`, `storage/`, `utils/` и т.д. Пример: весь тик-домен живёт внутри `include/DataFeedHub/data/ticks/` и собирается единым `ticks.hpp`.
- Для заголовков, содержащих **один главный тип**, используйте `CamelCase` в имени файла: `ValueTick.hpp`, `IConnection.hpp`. Это облегчает поиск: по имени класса сразу находится файл.
- Для утилитарных наборов сущностей используйте `snake_case`: `tick_codec_utils.hpp`, `market_event_listener.hpp`. Такой стиль подсказывает, что внутри несколько вспомогательных сущностей.
- Практика дублирования `#pragma once` и классического include guard обязательна. Шаблон защитного макроса: `_DFH_<PATH>_<FILENAME>_HPP_INCLUDED`. Пример: `_DFH_DATA_TICKS_VALUE_TICK_HPP_INCLUDED`.
- Каждый домен собирается «зонтичным» заголовком (`ticks.hpp`, `storage.hpp`, `compression.hpp`). При добавлении новых файлов включайте их в соответствующий umbrella-header и по возможности избегайте прямых include в листовых заголовках — порядок зависимостей должен контролироваться umbrella-файлом. Если требуется локальное подключение, снабдите код комментарием `// исключение` и приведите короткий пример, когда это оправдано.

## Правила именования
### Пространства имён и модули
- Корневое пространство — `dfh` и специализированные подобласти (`dfh::storage`). Внутри файлов код дополнительно отступается на 4 пробела, как видно в `include/DataFeedHub/data/ticks/ValueTick.hpp`. Пример:
  ```cpp
  namespace dfh {
      namespace storage {
          struct IConnection;
      }
  }
  ```

### Типы
- Классы, структуры, перечисления, псевдонимы — `CamelCase`: `ValueTick`, `IConnection`, `ConnectionPtr`. Это правило единообразно во всех доменах, включая `storage` и `compression`.
- Enum-константы — `CamelCase`: `Unknown`, `Buy`, `Sell`. Пример объявления:
  ```cpp
  enum class TradeSide { Unknown, Buy, Sell };
  ```

### Методы и функции
- Методы и свободные функции именуются в `snake_case`: `configure`, `connect`, `is_connected`. Геттеры могут называться как STL-подобные `size()`/`empty()` без префикса, что видно, например, в `TickSequence::size()`.
- Если метод делает заметную работу, допускается префикс `get_`. Пример: `get_latency_budget()` явно сигнализирует, что внутри идёт расчёт.

### Поля, переменные и параметры
- Обычные поля/переменные — `snake_case` (`value`, `time_ms`). Локальные auto/constexpr переменные следуют тому же стилю.
- Поля классов получают префикс `m_`: `m_task_manager`, `m_connection`. Булевым полям добавляйте `m_is_`/`m_has_`. Пример: `bool m_is_streaming = false;`.
- Параметры функций — `snake_case`. Дополнительные префиксы `p_`, `str_` разрешены, когда аргументов >5 и они разных типов. Это подчёркивает назначение параметров (`str_symbol`, `p_allocator`).

### Булевы переменные
- Используйте глагольные префиксы: `is_`, `has_`, `use_`, `enable_`. Для членов класса — `m_is_connected`. Пример локальной переменной: `bool has_updates = false;`.

### DTO и контейнеры доменов
- Шаблон для DTO: `<Base><Suffix><Kind>` (например, `ValueTick`, `FundingRateBar`, `OrderBookL2Snapshot`). Это подчёркивает принадлежность к домену и облегчает автодополнение.
- Алгоритмы и контейнеры именуются `<Kind><Action>`: `TickSequence`, `BarCompressorV2`. Пример расширения: `QuoteNormalizer`.
- Span-типы: `<TypeName>Span` (`ValueTickSpan`). Такой алиас явно говорит о zero-copy диапазоне.

### Константы и флаги
- Препроцессорные флаги и feature toggles — `UPPER_SNAKE_CASE` с префиксом `DFH_`: `DFH_USE_JSON`, `DFH_USE_NLOHMANN_JSON`. Макросы должны быть задокументированы рядом с объявлением, как в `include/DataFeedHub/storage/common/factory.hpp`.
- `static constexpr`/`const` поля — тоже `UPPER_SNAKE_CASE` и всегда квалифицируются при использовании: `ticks::TickCodecConfig::DEFAULT_CAPACITY`. Если значение используется в нескольких доменах, добавьте короткий комментарий с примером применения.

### Макросы включения
- Guard-имена согласованы с путём: `_DFH_DATA_VALUE_TICK_HPP_INCLUDED`, `_DFH_STORAGE_ICONNECTION_HPP_INCLUDED`. При создании файла сразу добавляйте пример комментария `// ValueTick.hpp` рядом с guard-ом, чтобы облегчить навигацию.

### Имена Git-коммитов
- Применяется Conventional Commits: `type(scope): message` (например, `docs(style): add RU style guide`). В качестве практического примера см. историю репозитория.

## Форматирование
- **Отступы:** 4 пробела, табы запрещены. Даже внутри namespace код получает дополнительный уровень отступа. Пример: тело `namespace dfh {` начинается с дополнительного отступа.
- **Ограничение строки:** старайтесь удерживать 100–120 символов, чтобы код удобно просматривался в diff. Длинные выражения переносите на соседние строки.
- **Фигурные скобки:** стиль K&R — открывающая скобка на той же строке, что и объявление (`struct ValueTick {`). Исключение — классические guards в макросах.
- **Инициализация:** предпочитайте uniform initialization или списки инициализации (`constexpr ValueTick(double v, std::uint64_t ts) noexcept : value(v), time_ms(ts) {}`). Такой подход исключает повторное присваивание в теле конструктора.
- **Выравнивание аргументов:** при переносе сигнатур и вызовов каждый параметр начинается с нового уровня отступа (8 пробелов относительно начала конструкции). Пример см. в `TickCodecConfig::init()`.
- **Указатели и ссылки:** `Type* ptr`, `const Foo& ref` — звёздочка/амперсанд примыкает к типу. Это уменьшает неоднозначность в шаблонном коде.
- **Include-порядок:** локальный заголовок, затем `<...>`, затем проектные `"..."`, между группами — пустая строка. Добавляйте комментарии `// standard`/`// project`, если блоков много.
- **Static assert и constexpr:** оформляйте многострочно с выравниванием по open paren, как в `ValueTick`. При необходимости приводите пример нарушения в сообщении статического assert.

## Документирование и комментарии
- Используйте тройные слэши `///`. Многострочные блочные комментарии `/** */` допускаются только при необходимости. Короткие описания внутри функций пишите обычными `//`.
- Описания лаконичны, технически нейтральны и на английском. Формулировки не начинаются со слова «The». Пример: `/// \brief Resize canvas to the target dimensions.`
- Порядок тегов фиксирован: `\brief`, `\tparam`, `\param`, `\return`, `\throws`, `\pre`, `\post`, `\invariant`, `\complexity`, `\thread_safety`, `\note/\warning`. Нарушение порядка затрудняет авто-генерацию документации.
- Каждый параметр/шаблонный параметр должен быть задокументирован. Не забывайте `\return` для невойдовых функций. Если параметров много, разбивайте комментарий на блоки с пустыми строками для читаемости.
- Указывайте сложность (`\complexity`) и потокобезопасность (`\thread_safety`). Пример: `\thread_safety Conditionally thread-safe: read operations are lock-free.`
- Комментарии к файлам (`\file`) и структурам обязательны для публичных заголовков. Внутри файла допускается короткая вводная секция `/// \file ...`.

## Feature toggles и условная компиляция
- JSON-хелперы оборачиваются в макросы `DFH_USE_JSON` + конкретный бэкенд (`DFH_USE_NLOHMANN_JSON`, `DFH_USE_SIMDJSON`). В комментарии рядом с `#ifdef` укажите краткий пример, какую функцию включает данный блок.
- Никогда не подключайте JSON-библиотеки, если `DFH_USE_JSON` не определён. Для проверки достаточно поискать по `rg "DFH_USE_JSON"` и убедиться, что зависимость защищена.
- Каждый новый домен с DTO обязан следовать той же схеме и скрывать сериализацию за этими макросами. При ревью указывайте пример, какие файлы затрагивает условие.

## Domain-driven дизайн
- Пространства имён повторяют границы доменов: `compression`, `core`, `data`, `storage`, `transform`, `utils`. Это упрощает поиск кода по префиксу (`rg "namespace storage"`).
- При добавлении функциональности определите её слой заранее и держите границы чистыми (данные ↔ хранилище ↔ утилиты). Если компонент «протекает» между слоями, опишите в комментарии пример зависимости, чтобы читателю было понятно исключение.
- Домены экспонируют umbrella-заголовки: используйте их, чтобы уменьшить граф включений. Листовые заголовки по возможности не должны тянуть зависимости самостоятельно. Пример: `include/DataFeedHub/storage.hpp` агрегирует `storage/common.hpp`, `storage/mdbx.hpp` и т.д.

## Практические рекомендации
1. **SerializeScratch вместо `thread_local`:** временные буферы реализуются через вспомогательную структуру с inline-буфером и владением на уровне вызывающего кода. Не создавайте `thread_local std::vector`/`std::string` — это приводит к крахам на Windows/MinGW из-за порядка разрушения. Подробный пример см. в описании `SerializeScratch` внутри репозитория.
2. **Предпочитайте ранний возврат** для уменьшения вложенности и читабельности. Например, проверяйте preconditions и выходите из функции до основного алгоритма.
3. **Разбивайте длинные функции** и не прячьте глобальное состояние: зависимости должны быть явными. Делегируйте код в статические helpers с говорящими именами.
4. **Enum class по умолчанию** для ограниченных множеств значений. Это защищает от неявных приведений; пример — `enum class StorageKind { Mdbx, Sqlite3 };`.
5. **Избегайте макросов в публичном API**, если они не нужны для портируемости. Если без макроса не обойтись, добавьте комментарий с примером использования и ожидаемыми значениями.
6. **Соблюдайте потоко-безопасность**: всегда отмечайте в документации, можно ли вызывать API из разных потоков. Укажите пример сценария (например, «вызывается из ingest-потока и читателя»).

Следуя этим правилам, любые новые файлы автоматически вписываются в текущий код-стиль (см. примеры в `include/DataFeedHub/data/ticks/ValueTick.hpp` и `include/DataFeedHub/storage/common/interfaces/IConnection.hpp`).
