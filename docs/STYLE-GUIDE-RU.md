# Руководство по стилю DataFeedHub

## Основные принципы
1. **Единая терминология**: именование сущностей следует доменным шаблонам (ticks, bars, storage и т.д.), чтобы код легко соотносился с архитектурой. Если появляется новое направление, сперва найдите существующие примеры в `include/DataFeedHub/<domain>/` и повторите шаблон.
2. **Читаемость и предсказуемость**: используем однозначные соглашения для имён, форматирования и документации, чтобы разные домены проекта выглядели одинаково. Соседние файлы всегда служат примером, на который можно ориентироваться.
3. **Безопасность и переносимость**: избегаем приёмов, которые ломаются на разных платформах (например, `thread_local` STL-хранилищ), и опираемся на специальные вспомогательные типы. Любой «нестандартный» трюк должен быть обоснован и снабжён ссылкой на пример использования.
4. **Документация первого класса**: каждое публичное API сопровождаем полным Doxygen-блоком с упорядоченными тегами, как показано на примерах в `include/DataFeedHub/storage/common/interfaces/IConnection.hpp`.

## Оглавление
1. [Организация исходников и файлов](#организация-исходников-и-файлов)
2. [Правила именования](#правила-именования)
3. [Форматирование](#форматирование)
4. [Документирование и комментарии](#документирование-и-комментарии)
5. [Feature toggles и условная компиляция](#feature-toggles-и-условная-компиляция)
6. [Domain-driven дизайн](#domain-driven-дизайн)
7. [Практические рекомендации](#практические-рекомендации)

## Организация исходников и файлов
- Заголовки преимущественно загружаются из `include/DataFeedHub/...`. Следуйте уже существующей иерархии: `compression/`, `data/`, `storage/`, `utils/` и т.д. Пример: весь тик-домен DTO живёт внутри `include/DataFeedHub/data/ticks/` и собирается единым `ticks.hpp`.
- Для заголовков, содержащих **один главный тип**, используйте `CamelCase` в имени файла, пример: `ValueTick.hpp`, `IConnection.hpp`. Это облегчает поиск: по имени класса сразу находится файл.
- Для утилитарных наборов сущностей используйте `snake_case`: `tick_codec_utils.hpp`, `market_event_listener.hpp`. Такой стиль подсказывает, что внутри несколько вспомогательных сущностей.
- Практика дублирования `#pragma once` и классического include guard обязательна. Шаблон защитного макроса: `_DFH_<PATH>_<FILENAME>_HPP_INCLUDED`. Пример: `_DFH_DATA_TICKS_VALUE_TICK_HPP_INCLUDED`.
- Каждый домен собирается «зонтичным» заголовком (`ticks.hpp`, `storage.hpp`, `compression.hpp`). При добавлении новых файлов включайте их в соответствующий *umbrella-header* и по возможности избегайте прямых include в листовых заголовках — порядок зависимостей должен контролироваться umbrella-файлом.

## Правила именования

### Пространства имён и модули

Корневое пространство — `dfh` и специализированные подобласти, например `dfh::storage`. Внутри файлов код дополнительно отступается на 4 пробела. Пример:

```cpp
namespace dfh {
    namespace storage {
        struct IConnection;
    }
}
```

### Типы

- Классы, структуры, перечисления, псевдонимы — `CamelCase`, например: `ValueTick`, `IConnection`, `ConnectionPtr`. Это правило единообразно во всех доменах.
- Enum-константы — `CamelCase`, например `Unknown`, `Buy`, `Sell`. Пример объявления:
  ```cpp
  enum class TradeSide { Unknown, Buy, Sell };
  ```

### Методы и функции

- Методы и свободные функции именуются в `snake_case`, например: `configure`, `connect`, `is_connected`. Геттеры могут называться как STL-подобные `size()`/`empty()` без префикса, например `TickSequence::size()`.
- Если метод делает заметную работу, допускается префикс `get_`. Пример: `get_latency_budget()` явно сигнализирует, что внутри идёт расчёт.

### Поля, переменные и параметры

- Обычные поля/переменные — `snake_case`, например: `value`, `time_ms`. Локальные auto/constexpr переменные следуют тому же стилю.
- Поля классов получают префикс `m_`: `m_task_manager`, `m_connection`. Булевым полям добавляйте `m_is_`/`m_has_`. Пример: `bool m_is_streaming = false;`.
- Параметры функций — `snake_case`. Дополнительные префиксы `p_`, `str_` разрешены, когда аргументов >5 и они разных типов. Это подчёркивает назначение параметров (`str_symbol`, `p_allocator`).

### Булевы переменные

- Используйте глагольные префиксы: `is_`, `has_`, `use_`, `enable_`. Для членов класса — `m_is_connected`. Пример локальной переменной: `bool has_updates = false;`.

### DTO и контейнеры доменов

- Шаблон для DTO: `<Base><Suffix><Kind>` (например, `ValueTick`, `FundingRateBar`, `OrderBookL2Snapshot`). Это подчёркивает принадлежность к домену и облегчает автодополнение.
- Алгоритмы и контейнеры именуются `<Kind><Action>`. Примеры: `TickSequence`, `BarCompressorV2`. Пример расширения: `QuoteNormalizer`.
- Span-типы: `<TypeName>Span` (например, `ValueTickSpan`). Такой алиас явно говорит о zero-copy диапазоне.

### Константы и флаги

- Препроцессорные флаги и feature toggles — `UPPER_SNAKE_CASE` с префиксом `DFH_`. Примеры: `DFH_USE_JSON`, `DFH_USE_NLOHMANN_JSON`. Макросы должны быть задокументированы рядом с объявлением.
- `static constexpr`/`const` поля — тоже `UPPER_SNAKE_CASE` и всегда квалифицируются при использовании, например: `ticks::TickCodecConfig::DEFAULT_CAPACITY`. Если значение используется в нескольких доменах, добавьте короткий комментарий с примером применения.

### Макросы включения

- Guard-имена согласованы с путём: `_DFH_DATA_VALUE_TICK_HPP_INCLUDED`, `_DFH_STORAGE_ICONNECTION_HPP_INCLUDED`. При создании файла сразу добавляйте пример комментария `// ValueTick.hpp` рядом с guard-ом, чтобы облегчить навигацию.

### Имена Git-коммитов

- Применяется Conventional Commits: `type(scope): message` (например, `docs(style): add RU style guide`).

## Форматирование

- **Отступы:** 4 пробела, табы запрещены. Даже внутри namespace код получает дополнительный уровень отступа. Пример: тело `namespace dfh {` начинается с дополнительного отступа.
- **Ограничение строки:** старайтесь удерживать 100–120 символов, чтобы код удобно просматривался в diff. Длинные выражения переносите на соседние строки.
- **Фигурные скобки:** стиль K&R — открывающая скобка на той же строке, что и объявление (например, `struct ValueTick {`). Исключение — классические guards в макросах.
- **Инициализация:** предпочитайте uniform initialization или списки инициализации (`constexpr ValueTick(double v, std::uint64_t ts) noexcept : value(v), time_ms(ts) {}`). Такой подход исключает повторное присваивание в теле конструктора.
- **Выравнивание аргументов:** при переносе сигнатур и вызовов каждый параметр начинается с нового уровня отступа (8 пробелов относительно начала конструкции).
- **Указатели и ссылки:** `Type* ptr`, `const Foo& ref` — звёздочка/амперсанд примыкает к типу. Это уменьшает неоднозначность в шаблонном коде.
- **Include-порядок:** локальный заголовок, затем `<...>`, затем проектные `"..."`, между группами — пустая строка. Добавляйте комментарии `// standard`/`// project`, если блоков много.
- **Static assert и constexpr:** оформляйте многострочно с выравниванием по open paren. При необходимости приводите пример нарушения в сообщении статического assert.

## Документирование и комментарии

- Используйте тройные слэши `///`. Многострочные блочные комментарии `/** */` допускаются только при необходимости. Короткие описания внутри функций пишите обычными `//`.
- Описания лаконичны, технически нейтральны и на английском. Формулировки не начинаются со слова «The». Пример: `/// \brief Resize canvas to the target dimensions.`
- Порядок тегов фиксирован: `\brief`, `\tparam`, `\param`, `\return`, `\throws`, `\pre`, `\post`, `\invariant`, `\complexity`, `\thread_safety`, `\note/\warning`. Нарушение порядка затрудняет авто-генерацию документации.
- Каждый параметр/шаблонный параметр должен быть задокументирован. Не забывайте `\return` для невойдовых функций. Если параметров много, разбивайте комментарий на блоки с пустыми строками для читаемости.
- Указывайте сложность (`\complexity`) и потокобезопасность (`\thread_safety`). Пример: `\thread_safety Conditionally thread-safe: read operations are lock-free.`
- Комментарии к файлам (`\file`) и структурам обязательны для публичных заголовков. Внутри файла допускается короткая вводная секция `/// \file ...`.

## Feature toggles и условная компиляция

- JSON-хелперы оборачиваются в макросы `DFH_USE_JSON` + конкретный бэкенд (`DFH_USE_NLOHMANN_JSON`, `DFH_USE_SIMDJSON`). В комментарии рядом с `#ifdef` укажите краткий пример, какую функцию включает данный блок.
- Никогда не подключайте JSON-библиотеки, если `DFH_USE_JSON` не определён. Для проверки достаточно поискать по `rg "DFH_USE_JSON"` и убедиться, что зависимость защищена.
- Каждый новый домен с DTO обязан следовать той же схеме и скрывать сериализацию за этими макросами. При ревью указывайте пример, какие файлы затрагивает условие.

## Domain-driven дизайн

- Пространства имён повторяют границы доменов: `compression`, `core`, `data`, `storage`, `transform`, `utils`. Это упрощает поиск кода по префиксу (`rg "namespace storage"`).
- При добавлении функциональности определите её слой заранее и держите границы чистыми (данные ↔ хранилище ↔ утилиты). Если компонент «протекает» между слоями, опишите в комментарии пример зависимости, чтобы читателю было понятно исключение.
- Домены экспонируют umbrella-заголовки: используйте их, чтобы уменьшить граф включений. Листовые заголовки по возможности не должны тянуть зависимости самостоятельно. Пример: `include/DataFeedHub/storage.hpp` агрегирует `storage/common.hpp`, `storage/mdbx.hpp` и т.д.

## Практические рекомендации

1. **SerializeScratch вместо `thread_local`:** временные буферы реализуются через вспомогательную структуру с inline-буфером и владением на уровне вызывающего кода. Не создавайте `thread_local std::vector`/`std::string` — это приводит к крахам на Windows/MinGW из-за порядка разрушения. Подробный пример см. в описании `SerializeScratch` внутри репозитория.
2. **Предпочитайте ранний возврат** для уменьшения вложенности и читабельности. Например, проверяйте preconditions и выходите из функции до основного алгоритма.
3. **Разбивайте длинные функции** и не прячьте глобальное состояние: зависимости должны быть явными. Делегируйте код в статические helpers с говорящими именами.
4. **Enum class по умолчанию** для ограниченных множеств значений. Это защищает от неявных приведений; пример — `enum class StorageKind { Mdbx, Sqlite3 };`.
5. **Избегайте макросов в публичном API**, если они не нужны для портируемости. Если без макроса не обойтись, добавьте комментарий с примером использования и ожидаемыми значениями.
6. **Соблюдайте потоко-безопасность**: всегда отмечайте в документации, можно ли вызывать API из разных потоков. Укажите пример сценария (например, «вызывается из ingest-потока и читателя»).
