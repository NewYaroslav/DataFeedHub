# Руководство по стилю DataFeedHub

## Основные принципы
1. **Единая терминология**: именование сущностей следует доменным шаблонам (ticks, bars, storage и т.д.), чтобы код легко соотносился с архитектурой.
2. **Читаемость и предсказуемость**: используем однозначные соглашения для имён, форматирования и документации, чтобы разные домены проекта выглядели одинаково.
3. **Безопасность и переносимость**: избегаем приёмов, которые ломаются на разных платформах (например, `thread_local` STL-хранилищ), и опираемся на специальные вспомогательные типы.
4. **Документация первого класса**: каждое публичное API сопровождаем полным Doxygen-блоком с упорядоченными тегами.

## Оглавление
1. [Организация исходников и файлов](#организация-исходников-и-файлов)
2. [Правила именования](#правила-именования)
3. [Форматирование](#форматирование)
4. [Документирование и комментарии](#документирование-и-комментарии)
5. [Feature toggles и условная компиляция](#feature-toggles-и-условная-компиляция)
6. [Domain-driven дизайн](#domain-driven-дизайн)
7. [Практические рекомендации](#практические-рекомендации)

## Организация исходников и файлов
- Заголовки преимущественно загружаются из `include/DataFeedHub/...`. Следуйте уже существующей иерархии: `compression/`, `data/`, `storage/`, `utils/` и т.д.
- Для заголовков, содержащих **один главный тип**, используйте `CamelCase` в имени файла: `ValueTick.hpp`, `IConnection.hpp`.
- Для утилитарных наборов сущностей используйте `snake_case`: `tick_codec_utils.hpp`, `market_event_listener.hpp`.
- Практика дублирования `#pragma once` и классического include guard обязательна. Шаблон защитного макроса: `_DFH_<PATH>_<FILENAME>_HPP_INCLUDED`.
- Каждый домен собирается «зонтичным» заголовком (`ticks.hpp`, `storage.hpp`, `compression.hpp`). При добавлении новых файлов включайте их в соответствующий umbrella-header и по возможности избегайте прямых include в листовых заголовках — порядок зависимостей должен контролироваться umbrella-файлом.

## Правила именования
### Пространства имён и модули
- Корневое пространство — `dfh` и специализированные подобласти (`dfh::storage`). Внутри файлов код дополнительно отступается на 4 пробела, как видно в `include/DataFeedHub/data/ticks/ValueTick.hpp`.

### Типы
- Классы, структуры, перечисления, псевдонимы — `CamelCase`: `ValueTick`, `IConnection`, `ConnectionPtr`.
- Enum-константы — `CamelCase`: `Unknown`, `Buy`, `Sell`.

### Методы и функции
- Методы и свободные функции именуются в `snake_case`: `configure`, `connect`, `is_connected`. Геттеры могут называться как STL-подобные `size()`/`empty()` без префикса.
- Если метод делает заметную работу, допускается префикс `get_`.

### Поля, переменные и параметры
- Обычные поля/переменные — `snake_case` (`value`, `time_ms`).
- Поля классов получают префикс `m_`: `m_task_manager`, `m_connection`. Булевым полям добавляйте `m_is_`/`m_has_`.
- Параметры функций — `snake_case`. Дополнительные префиксы `p_`, `str_` разрешены, когда аргументов >5 и они разных типов.

### Булевы переменные
- Используйте глагольные префиксы: `is_`, `has_`, `use_`, `enable_`. Для членов класса — `m_is_connected`.

### DTO и контейнеры доменов
- Шаблон для DTO: `<Base><Suffix><Kind>` (например, `ValueTick`, `FundingRateBar`, `OrderBookL2Snapshot`).
- Алгоритмы и контейнеры именуются `<Kind><Action>`: `TickSequence`, `BarCompressorV2`.
- Span-типы: `<TypeName>Span` (`ValueTickSpan`).

### Константы и флаги
- Препроцессорные флаги и feature toggles — `UPPER_SNAKE_CASE` с префиксом `DFH_`: `DFH_USE_JSON`, `DFH_USE_NLOHMANN_JSON`.
- `static constexpr`/`const` поля — тоже `UPPER_SNAKE_CASE` и всегда квалифицируются при использовании: `ticks::TickCodecConfig::DEFAULT_CAPACITY`.

### Макросы включения
- Guard-имена согласованы с путём: `_DFH_DATA_VALUE_TICK_HPP_INCLUDED`, `_DFH_STORAGE_ICONNECTION_HPP_INCLUDED`.

### Имена Git-коммитов
- Применяется Conventional Commits: `type(scope): message` (например, `docs(style): add RU style guide`).

## Форматирование
- **Отступы:** 4 пробела, табы запрещены. Даже внутри namespace код получает дополнительный уровень отступа.
- **Ограничение строки:** старайтесь удерживать 100–120 символов.
- **Фигурные скобки:** стиль K&R — открывающая скобка на той же строке, что и объявление (`struct ValueTick {`).
- **Инициализация:** предпочитайте uniform initialization или списки инициализации (`constexpr ValueTick(double v, std::uint64_t ts) noexcept : value(v), time_ms(ts) {}`).
- **Выравнивание аргументов:** при переносе сигнатур и вызовов каждый параметр начинается с нового уровня отступа (8 пробелов относительно начала конструкции).
- **Указатели и ссылки:** `Type* ptr`, `const Foo& ref` — звёздочка/амперсанд примыкает к типу.
- **Include-порядок:** локальный заголовок, затем `<...>`, затем проектные `"..."`, между группами — пустая строка.
- **Static assert и constexpr:** оформляйте многострочно с выравниванием по open paren, как в `ValueTick`.

## Документирование и комментарии
- Используйте тройные слэши `///`. Многострочные блочные комментарии `/** */` допускаются только при необходимости.
- Описания лаконичны, технически нейтральны и на английском.
- Порядок тегов фиксирован: `\brief`, `\tparam`, `\param`, `\return`, `\throws`, `\pre`, `\post`, `\invariant`, `\complexity`, `\thread_safety`, `\note/\warning`.
- Каждый параметр/шаблонный параметр должен быть задокументирован. Не забывайте `\return` для невойдовых функций.
- Указывайте сложность (`\complexity`) и потокобезопасность (`\thread_safety`).
- Комментарии к файлам (`\file`) и структурам обязательны для публичных заголовков.

## Feature toggles и условная компиляция
- JSON-хелперы оборачиваются в макросы `DFH_USE_JSON` + конкретный бэкенд (`DFH_USE_NLOHMANN_JSON`, `DFH_USE_SIMDJSON`).
- Никогда не подключайте JSON-библиотеки, если `DFH_USE_JSON` не определён.
- Каждый новый домен с DTO обязан следовать той же схеме и скрывать сериализацию за этими макросами.

## Domain-driven дизайн
- Пространства имён повторяют границы доменов: `compression`, `core`, `data`, `storage`, `transform`, `utils`.
- При добавлении функциональности определите её слой заранее и держите границы чистыми (данные ↔ хранилище ↔ утилиты).
- Домены экспонируют umbrella-заголовки: используйте их, чтобы уменьшить граф включений. Листовые заголовки по возможности не должны тянуть зависимости самостоятельно.

## Практические рекомендации
1. **SerializeScratch вместо `thread_local`:** временные буферы реализуются через вспомогательную структуру с inline-буфером и владением на уровне вызывающего кода. Не создавайте `thread_local std::vector`/`std::string` — это приводит к крахам на Windows/MinGW из-за порядка разрушения.
2. **Предпочитайте ранний возврат** для уменьшения вложенности и читабельности.
3. **Разбивайте длинные функции** и не прячьте глобальное состояние: зависимости должны быть явными.
4. **Enum class по умолчанию** для ограниченных множеств значений.
5. **Избегайте макросов в публичном API**, если они не нужны для портируемости.
6. **Соблюдайте потоко-безопасность**: всегда отмечайте в документации, можно ли вызывать API из разных потоков.

Следуя этим правилам, любые новые файлы автоматически вписываются в текущий код-стиль (см. примеры в `include/DataFeedHub/data/ticks/ValueTick.hpp` и `include/DataFeedHub/storage/common/interfaces/IConnection.hpp`).
